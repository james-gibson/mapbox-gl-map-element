<link rel="import" href="../polymer/polymer.html">
<link rel="stylesheet" href="../mapbox-gl-js/mapbox-gl.css">
<script src="../mapbox-gl-js/mapbox-gl.js"></script>

<!--
Wrapper element around mapbox-gl map API.

Example:
    <code>&lt;mgl-map lat="..." lng="..."&gt;&lt;/mgl-map&gt;</code>

@demo
-->
<dom-module id="mgl-map">

  <style>
    :host {
      box-sizing: border-box;
      display: block;
      overflow: hidden;
      position: relative;
    }
    #map {
      bottom: 0;
      left: 0;
      position: absolute;
      right: 0;
      top: 0;
      z-index: 0;
    }
    #div-markers {
      height: 0;
      left: 50%;
      position: absolute;
      top: 50%;
      width: 0;
      z-index: 1;
    }
    #div-markers content::content [marker] {
      left: 0;
      position: absolute;
      top: 0;
    }
  </style>

  <template>
    <div id="map"></div>
    <content select="mgl-marker"></content>
    <div id="div-markers">
      <content select="[marker]"></content>
    </div>
  </template>

</dom-module>

<script>
(function() {
  // When lat, lng, zoom are asigned in a row, 
  // wait 'WAIT_TIME' before moving the map so it moves just once
  var WAIT_TIME = 1; // ms
  
  Polymer({
    is: 'mgl-map',

    properties: {
      options: Object,
      lat: {
        type: Number,
        reflectToAttribute: true,
        value: 0
      },
      lng: {
        type: Number,
        reflectToAttribute: true,
        value: 0
      },
      zoom: {
        type: Number,
        value: 5,
        reflectToAttribute: true
      }
    },

    observers: [
      'updatePosition(lat, lng, zoom)',
      'updateStyleOpt(options.style)',
      'updateTokenOpt(options.token)',
    ],

    created: function() {
      this._move = true;
    },

    ready: function() {
      var self = this,
        markerElements = this.$['div-markers'].firstElementChild.getDistributedNodes(),
        mapTransform;
      // set map options
      this.options = typeof this.options === 'object' ? this.options : {};
      this.options.container = this.$.map;
      this.mgl = new mapboxgl.Map(this.options);
      mapTransform = this.mgl.transform;

      // resize map to fill container after fully loaded
      this.mgl.on('load', function() {
        self.mgl.resize();
      });
      // set lat, lng, zoom when map changes
      this.mgl.on('moveend', mapMoved.bind(this));
      // manually set lat, lng on initialization
      this.setCenter([this.lat, this.lng]);
      
      // div markers positioning
      // set container position
      transform(self.$['div-markers'], -mapTransform.x, -mapTransform.y, -mapTransform.bearing, true);
      // set markers position
      positionMarkers(markerElements, mapTransform);
      // listen to map movement
      this.mgl.on('move', function(e) {
        transform(self.$['div-markers'], -mapTransform.x, -mapTransform.y, -mapTransform.bearing, true);
      });
      // relocate markers when zooming
      this.mgl.on('zoom', function(e) {
        transform(self.$['div-markers'], -mapTransform.x, -mapTransform.y, -mapTransform.bearing, true);
        positionMarkers(markerElements, mapTransform);
      });
      // rotate markers in the oposite direction of map's rotation
      this.mgl.on('rotate', function(e) {
        positionMarkers(markerElements, mapTransform);
      });
    },

    // property changes
    // options changes
    updateStyleOpt: function(style) {
      if (this.mgl) {
        this.mgl.setStyle(style);      
      }
    },
    
    updateTokenOpt: function(token) {
      mapboxgl.accessToken = token;
    },
    
    /**
     *  
     */
    updatePosition: function(lat, lng, zoom) {
      var self = this;
      clearTimeout(this._moveTimeout);
      if (this._move) {
        this._moveTimeout = setTimeout(function() {
            jumpTo(self, {center: [lat, lng], zoom: zoom}, true);
        }, WAIT_TIME);
      }
      this._move = true;
    },

    // public methods
    setCenter: function(center, animate) {
      jumpTo(this, {center: center}, animate);
    },

    setZoom: function(zoom, animate) {
      jumpTo(this, {zoom: zoom}, animate);
    }
  });

  function mapMoved() {
    var center = this.mgl.getCenter();
    assignIfDifferent(this, 'lat', center.lat);
    assignIfDifferent(this, 'lng', center.lng);
    assignIfDifferent(this, 'zoom', this.mgl.getZoom());
  }

  function assignIfDifferent(self, name, val) {
    if (self[name] !== val) {
      self._move = false;
      self[name] = val;
    }
  }

  function jumpTo(self, opts, animate) {
    var animate = animate || false,
      options = {
        center: [self.lat, self.lng],
        zoom: self.zoom,
        bearing: 0,
        pitch: 0
      };
    Polymer.Base.extend(options, opts);
    if (self.mgl) {
      if (animate) {
        self.mgl.flyTo(options);
      } else {
        self.mgl.jumpTo(options);
      }
    }
  }
  
  /**
   *  Position div markers
   */
  function positionMarkers(markers, mTransform) {
    markers = Array.prototype.slice.call(markers);
    markers.forEach(function(m) {
      var lat = +m.getAttribute('lat') || 0,
        lng = +m.getAttribute('lng') || 0,
        x = mTransform.lngX(lng);
        y = mTransform.latY(lat);
      transform(m, x, y, mTransform.bearing);
    });
  }
  
  function transform(ele, x, y, rotate, rotateFirst) {
    var rotateFirst = rotateFirst || false,
      rotate = rotate || 0;
      rotation = 'rotate(' + rotate + 'deg)',
      translation = 'translate3d(' + x + 'px,' + y + 'px, 0)';
    ele.style.transform = rotateFirst ? rotation + ' ' + translation : translation + ' ' + rotation;
  }
  
})();
</script>
