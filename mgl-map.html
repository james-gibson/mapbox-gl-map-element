<link rel="import" href="../polymer/polymer.html">
<link rel="stylesheet" href="../mapbox-gl-js/mapbox-gl.css">
<script src="../mapbox-gl-js/mapbox-gl.js"></script>

<!--
Wrapper element around mapbox-gl map API.

Example:
    <code>&lt;mgl-map lat="..." lng="..."&gt;&lt;/mgl-map&gt;</code>

@demo
-->
<dom-module id="mgl-map">

  <style>
    :host {
      box-sizing: border-box;
      display: block;
      overflow: hidden;
      position: relative;
    }
    #map {
      bottom: 0;
      left: 0;
      position: absolute;
      right: 0;
      top: 0;
      z-index: 0;
    }
    #div-markers {
      height: 0;
      left: 50%;
      position: absolute;
      top: 50%;
      width: 0;
      z-index: 1;
    }
    #div-markers content::content [marker] {
      left: 0;
      position: absolute;
      top: 0;
    }
  </style>

  <template>
    <div id="map"></div>
    <div id="div-markers">
      <content select="[marker]"></content>
    </div>
    <content select="mgl-marker"></content>
  </template>

</dom-module>

<script>
(function() {
  Polymer({
    is: 'mgl-map',

    properties: {
      options: Object,
      lat: {
        type: Number,
        reflectToAttribute: true,
        value: 0
      },
      lng: {
        type: Number,
        reflectToAttribute: true,
        value: 0
      },
      zoom: {
        type: Number,
        value: 5,
        reflectToAttribute: true
      }
    },

    observers: [
      'updatePosition(lat, lng, zoom)',
      'updateStyleOpt(options.style)',
      'updateTokenOpt(options.token)',
    ],

    ready: function() {
      var self = this;
      // set map options
      this.options = typeof this.options === 'object' ? this.options : {};
      this.options.container = this.$.map;
      this.mgl = new mapboxgl.Map(this.options);
      
      // resize map to fill container after fully loaded
      this.mgl.on('load', function() { self.mgl.resize(); });
      // set lat, lng, zoom when map changes
      this.mgl.on('moveend', mapMoved.bind(this));
      // manually set lat, lng on initialization
      this.setCenter([this.lat, this.lng]);
      
      // div markers positioning
      this._positionMrksLayer();
      this._positionMrks();
      // listen to map movement
      this.mgl.on('move', function() { self._positionMrksLayer(); });
      // relocate markers when zooming
      this.mgl.on('zoom', function() {
        self._positionMrksLayer();
        self._positionMrks();
      });
      // markers are rotated in the oposite direction of map's rotation
      this.mgl.on('rotate', function() { self._positionMrks(); });
      // position added/modified markers
      var observer = new MutationObserver(function(mutations) {
          mutations.forEach(function(m) {
              var element = m.type === 'attributes' ? m.target : m.addedNodes[0];
              if (element instanceof HTMLElement && element.hasAttribute('marker')) {
                positionMarker(element, self.mgl.transform);
              }
          });
      });
      observer.observe(this, {childList: true, subtree: true, attributes: true, attributeFilter: ['lat', 'lng']});
    },
    
    _positionMrksLayer: function() {
      var t = this.mgl.transform;
      translateRotate(this.$['div-markers'], -t.x, -t.y, -t.bearing, true);
    },
    
    _positionMrks: function() {
      var markers = this.getContentChildren();
      markers.forEach(function(m) {
        positionMarker(m, this.mgl.transform);
      }, this);
    },

    // property changes
    // options changes
    updateStyleOpt: function(style) {
      if (this.mgl) {
        this.mgl.setStyle(style);
      }
    },
    
    updateTokenOpt: function(token) {
      mapboxgl.accessToken = token;
    },
    
    /**
     *  
     */
    updatePosition: function(lat, lng, zoom) {
      var self = this;
      this.debounce('movemap', function() {
        jumpTo(self, {center: [lat, lng], zoom: zoom}, true);
      });
    },

    // public methods
    setCenter: function(center, animate) {
      jumpTo(this, {center: center}, animate);
    },

    setZoom: function(zoom, animate) {
      jumpTo(this, {zoom: zoom}, animate);
    }
  });

  function mapMoved() {
    var center = this.mgl.getCenter();
    this.lat = center.lat;
    this.lng = center.lng;
    this.zoom = this.mgl.getZoom();
  }

  function jumpTo(self, opts, animate) {
    animate = animate || false;
    var options = {
        center: [self.lat, self.lng],
        zoom: self.zoom,
        bearing: 0,
        pitch: 0
      };
    Polymer.Base.extend(options, opts);
    if (self.mgl) {
      if (animate) {
        self.mgl.flyTo(options);
      } else {
        self.mgl.jumpTo(options);
      }
    }
  }
  
  function positionMarker(element, transform) {
    var lat = +element.getAttribute('lat') || 0,
        lng = +element.getAttribute('lng') || 0,
        x = transform.lngX(lng),
        y = transform.latY(lat);
    translateRotate(element, x, y, transform.bearing);
  }
  
  function translateRotate(ele, x, y, angle, rotateFirst) {
    rotateFirst = rotateFirst || false;
    angle = angle || 0;
    var rotation = 'rotate(' + angle + 'deg)',
        translation = 'translate3d(' + x + 'px,' + y + 'px, 0)';
    ele.style.transform = rotateFirst ? rotation + ' ' + translation : translation + ' ' + rotation;
  }
  
})();
</script>
